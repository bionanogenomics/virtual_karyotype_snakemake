import numpy as np
import pandas as pd
import argparse
import re
import ast
pd.set_option('mode.chained_assignment', None)


def format_iscn_results(iscn_format, cytobands, cytobands_out, genome_out, contig_orientation_out, kprect_out, smap_segments, vk_results, svlabel_frame_out):
    """
    Formats ISCN Virtual Karyotype results into KaryoploteR format

    Parameters
    ----------
    iscn_format: str, required
        {sample}_results_ISCN.txt generated by rule: run_vk
    cytobands: str, required
        Cytoband file located in resources folder (cytoBand.txt)
        columns: chr, start, end, band, gieStain
    cytobands_out: str, required
        relative path to sample specific KaryoploteR formatted cytoband file
    genome_out: str, required
        relative path to sample specific KaryoploteR formatted genome file
    contig_orientation_out: str, required
        relative path to sample specific contig orientation file 
    kprect_out: str, required
        relative path to sample specific kprect parameters file
    smap_segments: str, required
        {sample}_smap_segments.txt generated by rule: run_vk
    vk_results: str, required
        {sample}_results.txt generated by rule: run_vk
    """
    cytoband_filtered = read_in_custom_cyto(cytobands = cytobands)
    iscn_results = pd.read_table(iscn_format, sep=' = ',engine='python',header=None)
    iscn_results.columns = ['paths','iscn']
    iscn_split_coords = iscn_results['iscn'].str.split(',')
    iscn_paths = iscn_results['paths']
    cytoband_paths = []
    for path,coord in zip(iscn_paths,iscn_split_coords):
        for seg in coord:
            chrom_seg = seg.split('(')[0]
            chrom = return_chrom(chrom_seg)
            start,end = seg.split('(')[1].split(')')[0].split('-')
            strand = seg.split('(')[2].split(')')[0]
            sub_cyto = map_cyto_coords(chrom, start, end, strand, cytoband_filtered, path)
            cytoband_paths.append(sub_cyto)
    iscn_cyto = pd.concat(cytoband_paths)
    iscn_cyto_grouped = iscn_cyto.groupby('name')
    intervals_out_list = []
    for path,sub_cyto_frame in iscn_cyto_grouped:
        intervals = check_paths(sub_cyto_frame, path)
        intervals_out_list.append(intervals)
    interval_out = pd.concat(intervals_out_list)
    iscn_cyto['chrom'] = iscn_cyto['chr']
    iscn_cyto['chr'] = iscn_cyto['name']
    interval_out['contig_id'] = interval_out['contig_id'].replace({'23':'X','24':'Y'})
    path_map_dict = interval_out.loc[:,['path','contig_id']].drop_duplicates().set_index('path').to_dict()['contig_id']
    update_mapper = {k:'{} : {}'.format(k,v) for k,v in path_map_dict.items()}
    iscn_cyto['chr'] = iscn_cyto['chr'].map(update_mapper)
    iscn_cyto.rename(columns={'stain':'gieStain','name':'Path','band':'name'},inplace=True)
    resolved_cyto_non_orient, resolved_stain = resolve_iscn_cyto(iscn_cyto)
    resolved_cyto = orient_p_to_q(resolved_cyto_non_orient)
    resolved_cyto.rename(columns={'gieStain':'original_stain','Resolved_stain':'gieStain','name':'original_name','Resolved_band':'name'},inplace=True)
    resolved_cyto['start'] = resolved_cyto['start'] + 1
    resolved_cyto['end'] = resolved_cyto['end'] + 1 
    resolved_cyto.to_csv(cytobands_out, sep='\t',index=False)
    resolved_cyto['delta'] = resolved_cyto['end'] - resolved_cyto['start']
    path_order = resolved_cyto['chr'].unique().tolist()
    custom_genome = resolved_cyto.loc[:,['chr','delta']].groupby('chr').sum().sort_values('chr').reset_index()
    custom_genome.chr = custom_genome.chr.astype('category')
    custom_genome.chr = custom_genome.chr.cat.set_categories(path_order)
    custom_genome['start'] = 1
    custom_genome['end'] = custom_genome['delta']
    custom_genome_out = custom_genome.reindex(['chr','start','end'],axis=1).sort_values('chr')
    custom_genome_out.to_csv(genome_out,sep='\t',index=False)
    segment_frame_filtered = parse_smap_segments(smap_segments)
    generate_karyoploter_plotting_params(resolved_cyto, segment_frame_filtered, vk_results, contig_orientation_out, kprect_out, svlabel_frame_out)

def generate_karyoploter_plotting_params(resolved_cyto, segment_frame_filtered, vk_results, contig_orientation_out, kprect_out, svlabel_frame_out):
    """
    Generates both kprect and contig_orientation plotting parameters to be used during figure generation step

    Parameters
    ----------
    resolved_cyto: DataFrame, required
        DataFrame of resolved ISCN cytoband embedded paths generated by function: resolve_iscn_cyto()
    segment_frame_filtered: DataFrame, required
        DataFrame of resolved SV smap entries with embedded paths generated by function: parse_smap_segments()
    contig_orientation_out : str, required
        handle for output contig orientation file 
    kprect_out: str, required
        handle for output contig orientation file
    """
    # contig_orientation_frame = generate_orientation_arrow_coordinates(resolved_cyto)
    # path_segments = extract_segments(vk_results) -> Deprecated
    svlabel_frame = generate_sv_label_frame(segment_frame_filtered, vk_results)
    svlabel_frame_final = interset_labels_with_cyto(resolved_cyto,svlabel_frame)
    svlabel_frame_final.to_csv(svlabel_frame_out,sep="\t",index=False)
    # Tomorrow - review VK vertices to see if I can find adjacent nodes in graph created by SV, see line 1136 i.e node_to_map_dict, node_to_smap_dict = node_to_map(svs, xmap, g)
    # Also intersect svlabel_frame with resolved_cyto, and pass filtered frame to generate_inversion_orientation_arrow_coordinates
    contig_orientation_frame = generate_inversion_orientation_arrow_coordinates(resolved_cyto, segment_frame_filtered)
    kprect_frame = generate_kprect_coordinates(resolved_cyto)

    contig_orientation_frame.to_csv(contig_orientation_out,sep='\t',index=False)
    kprect_frame.to_csv(kprect_out,sep='\t',index=False)

def interset_labels_with_cyto(resolved_cyto,svlabel_frame):
    """

    Args:
        resolved_cyto (_type_): _description_
        svlabel_frame (_type_): _description_
    """
    path_map = resolved_cyto.loc[:,['chr','Path']].set_index('Path').to_dict()['chr']
    svlabel_frame['chr'] = svlabel_frame['Paths'].map(path_map)
    svlabel_frame['pos'] = svlabel_frame.loc[:,['ref_start','ref_end']].mean(axis=1) 
    svlabel_frame['labels'] = svlabel_frame['sv_type'] + " - mapid: " + svlabel_frame['q_id'].astype(str)
    return svlabel_frame

def parse_file(filename):
    """
    Parse a given text file and extract lines of interest. 
    
    The function starts capturing lines when it encounters a line 
    starting with "Path". From that point, it captures every third 
    line. The process repeats for each line starting with "Path".
    
    Parameters:
    - filename (str): The name of the file to be parsed.

    Returns:
    - list: A list of extracted lines from the file.

    Example:
    Given a file containing:
    ...
    Random line
    Path1 = Some data
    Irrelevant line 1
    Irrelevant line 2
    Captured line 1
    Irrelevant line 3
    Irrelevant line 4
    Captured line 2
    ...
    The function will return:
    ["Path1 = Some data", "Captured line 1", "Captured line 2", ...]
    """
    # Open the file and read its lines into a list.
    with open(filename, 'r') as file:
        lines = file.readlines()
    # Initialize an empty list to store the extracted lines.
    output = []
    # Flag to determine if we are in the capturing mode.
    start = False
    # Iterate over each line in the file.
    for index, line in enumerate(lines):
        # If the line starts with "Path", start capturing and reset counter.
        if not start and line.startswith("Path"):
            output.append(line.strip())  # Append the current line to the output.
            start = True                # Set the capturing flag to True.
            counter = 0                 # Initialize or reset the counter.
            continue                    # Skip to the next iteration.
        # If we're in capturing mode:
        if start:
            counter += 1  # Increment the counter.
            # If counter is 3, append the current line and reset counter.
            if counter == 3:
                output.append(line.strip())
                counter = 0
    output 
    return output

def extract_segments(filename):
    """
    Parse a given text file and extract segments of interest. 
    The function starts capturing segments when it encounters a line 
    starting with "Path". From that point, it captures every third 
    line. The process repeats for each line starting with "Path".
    Parameters:
    - filename (str): The name of the file to be parsed.
    Returns:
    - list of tuples: Each tuple contains ('Path', 'Segment').
    """
    with open(filename, 'r') as file:
        lines = file.readlines()
    results = []
    start = False
    for index, line in enumerate(lines):
        if not start and line.startswith("Path"):
            path_name = line.split('=')[0].strip()
            segments = re.findall(r"\d+", line.split('=')[1])  # Extract only digits
            print(segments)
            for segment in segments:
                segment_name = "Segment " + segment  # Add the "Segment" prefix
                results.append((path_name, segment_name))
            start = True
            counter = 0
            continue
        if start:
            counter += 1
            if counter == 3:
                path_name = line.split('=')[0].strip()
                segments = re.findall(r"\d+", line.split('=')[1])  # Extract only digits
                for segment in segments:
                    segment_name = "Segment " + segment  # Add the "Segment" prefix
                    results.append((path_name, segment_name))
                counter = 0
    df = pd.DataFrame(results, columns=['Paths', 'Segments']).drop_duplicates()
    return df

def filter_dataframe(df, insertion_size=500000, inversion_size=500000, deletion_size=200000):
    """
    Filters the provided DataFrame based on the given conditions.
    Parameters:
    - df (pd.DataFrame): Input DataFrame with at least columns 'sv_type' and 'size'.
    - insertion_size (int): Threshold size for 'insertion'. Default is 500,000.
    - inversion_size (int): Threshold size for 'inversion'. Default is 500,000.
    - deletion_size (int): Threshold size for 'deletion'. Default is 200,000.
    Returns:
    - pd.DataFrame: Filtered DataFrame based on the conditions.
    """
    # Filter for insertions with size above the given threshold
    insertion_condition = (df['sv_type'] == 'insertion') & (df['size'] > insertion_size)
    # Filter for inversions (starting with the word 'inversion') with size above the given threshold
    inversion_condition = df['sv_type'].str.startswith('inversion') & (df['size'] > inversion_size)
    # Filter for deletions with size above the given threshold
    deletion_condition = (df['sv_type'] == 'deletion') & (df['size'] > deletion_size)
    # Filter for translocation_intrachr
    translocation_condition = df['sv_type'] == 'translocation_intrachr'
    # Combine all conditions with an OR operator
    combined_condition = insertion_condition | inversion_condition | deletion_condition | translocation_condition
    return df[combined_condition]


def generate_sv_label_frame(segment_frame_filtered, vk_results):
    """_summary_

    Args:
        segment_frame_filtered (_type_): _description_
        vk_results (_type_): _description_
    """
    path_segment_frame = extract_segments(vk_results)
    exploded_frame = segment_frame_filtered.explode('Paths')
    exploded_frame['Paths'] =exploded_frame['Paths'].str.replace(' ','')
    grouped_paths = path_segment_frame.groupby('Paths')
    filtered = []
    for path,path_frame in grouped_paths:
        subset = exploded_frame[exploded_frame['Paths'] == path]
        subset_final = subset[subset['Segments'].isin(path_frame['Segments'])]
        filtered.append(subset_final)
    filtered_segments = pd.concat(filtered)
    size_filtered_segments = filter_dataframe(filtered_segments)
    return size_filtered_segments 

def generate_inversion_orientation_arrow_coordinates(resolved_cyto, segment_frame_filtered):
    """
    Generates orienation arrow plotting parameter file

    Parameters
    ----------
    resolved_cyto: DataFrame, required
        DataFrame of collapsed orientation segments generated by function: resolved_cyto()
    Returns
    -------
    collapsed_segments: DataFrame
        Orientation resolved collapsed_segments Dataframe
    """
    inversion_frame = segment_frame_filtered[(segment_frame_filtered['sv_type']=='inversion') & (segment_frame_filtered['size']>=500000)].explode('Paths')
    inversion_frame['Paths'] = inversion_frame['Paths'].str.replace(' ','')
    collapsed_segment_list = []
    grouped_iscn = resolved_cyto.groupby('Path',sort=False)
    for g,frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        indx_final = frame.index.max()
        if g in inversion_frame['Paths'].values:
            inversion_calls = inversion_frame[inversion_frame['Paths']==g]
            for indx,row in inversion_calls.iterrows():
                segment_start = frame.iloc[0].to_frame().T
                segment_start['start'] = row.ref_start
                segment_start['end'] = row.ref_end
                segment_start['color'] = 'red'
                collapsed_segment_list.append(segment_start)
    if collapsed_segment_list:
        collapsed_segments= pd.concat(collapsed_segment_list).sort_values(['Path','start','end'])
    else:
        collapsed_segments = pd.DataFrame() # Will need to add check in R to see if this is empty
    return collapsed_segments


def swap_negative_orientation(collapsed_segments):
    """
    Swaps start and end positions for segments of orientation file with negative orientation

    Parameters
    ----------
    collapsed_segments: DataFrame, required
        DataFrame of collapsed orientation segments generated by function: generate_orientation_arrow_coordinates()
    Returns
    -------
    collapsed_segments: DataFrame
        Orientation resolved collapsed_segments Dataframe
    """
    idx = collapsed_segments['strand'] == '-'
    collapsed_segments.loc[idx,['start','end']] = collapsed_segments.loc[idx,['end','start']].values
    return collapsed_segments

def generate_orientation_arrow_coordinates(resolved_cyto):
    """
    Generates orienation arrow plotting parameter file

    Parameters
    ----------
    resolved_cyto: DataFrame, required
        DataFrame of collapsed orientation segments generated by function: resolved_cyto()
    Returns
    -------
    collapsed_segments: DataFrame
        Orientation resolved collapsed_segments Dataframe
    """
    collapsed_segment_list = []
    grouped_iscn = resolved_cyto.groupby('Path',sort=False)
    for g,frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        indx_final = frame.index.max()
        for indx,row in frame.iterrows():
            if indx == 0:
                segment_start = row
            if (segment_start.strand != row.strand) | (segment_start.chrom != row.chrom):
                append_row = frame.iloc[indx-1]
                append_row.start = segment_start.start
                collapsed_segment_list.append(append_row.to_frame().T)
                segment_start = row
            if (indx == indx_final) & (segment_start == row).all():
                collapsed_segment_list.append(row.to_frame().T)
            if (indx == indx_final) & (segment_start != row).any():
                append_row = row
                append_row.start = segment_start.start
                collapsed_segment_list.append(append_row.to_frame().T)
    collapsed_segments= pd.concat(collapsed_segment_list).sort_values(['Path','start','end'])
    map_dict = {'+':'blue','-':'red'}
    collapsed_segments['color'] = collapsed_segments['strand'].map(map_dict)
    collapsed_segments = swap_negative_orientation(collapsed_segments)
    return collapsed_segments

def generate_kprect_coordinates(resolved_cyto):
    """
    Generates kprect - contig specific plotting parameter file

    Parameters
    ----------
    resolved_cyto: DataFrame, required
        DataFrame of collapsed orientation segments generated by function: resolved_cyto()
    Returns
    -------
    collapsed_segments: DataFrame
        Orientation resolved collapsed_segments Dataframe
    """
    collapsed_segment_list = []
    grouped_iscn = resolved_cyto.groupby('Path',sort=False)
    for g,frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        indx_final = frame.index.max()
        for indx,row in frame.iterrows():
            if indx == 0:
                segment_start = row
            if (segment_start.chrom != row.chrom):
                append_row = frame.iloc[indx-1]
                append_row.start = segment_start.start
                collapsed_segment_list.append(append_row.to_frame().T)
                segment_start = row
            if (indx == indx_final) & (segment_start == row).all():
                collapsed_segment_list.append(row.to_frame().T)
            if (indx == indx_final) & (segment_start != row).any():
                append_row = row
                append_row.start = segment_start.start
                collapsed_segment_list.append(append_row.to_frame().T)
    collapsed_segments= pd.concat(collapsed_segment_list).sort_values(['Path','start','end'])
    collapsed_segments['midpoint'] = collapsed_segments.loc[:,['start','end']].mean(axis=1)
    return collapsed_segments

def resolve_iscn_cyto(iscn_cyto):
    """
    Resolves non-contiguous genomic segments and embeds major cytobands in paths detected by VK algorithm

    Parameters
    ----------
    iscn_cyto: DataFrame, required
        DataFrame of ISCN coordinates generated within the function: format_iscn_results()
    Returns
    -------
    resolved_stain_collapsed_cyto: DataFrame
        Orientation resolved collapsed_segments Dataframe generated by collapse_bands()
    resolved_cyto: DataFrame
        Orientation resolved collapsed_segments Dataframe
    resolved_stain_cyto: DataFrame
        Orientation resolved collapsed_segments Dataframe generated by resolve_iscn_bands()
    """
    iscn_cyto_copy = iscn_cyto.copy()
    cols = iscn_cyto_copy.columns.tolist()
    cols = cols + ['bp','original_start', 'original_end']
    iscn_cyto_copy['bp'] = False
    iscn_cyto_copy['original_start'] = iscn_cyto_copy['start']
    iscn_cyto_copy['original_end'] = iscn_cyto_copy['end']
    iscn_cyto_copy = iscn_cyto_copy.reindex(cols,axis=1)
    cyto_list = []
    cols = iscn_cyto_copy.columns.tolist()
    grouped_iscn = iscn_cyto_copy.groupby('Path')
    for g,frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        for i,row in frame.iterrows():
            if i == 0:
                if row.start != 0:
                    new_end = (row.end - row.start) 
                    frame.iloc[i] = [row.chr, 0, new_end, row['name'], row.gieStain, row.band_base, row.Updated_stain, row.Resolved_band, row.Resolved_stain, row.Path, row.strand, row.chrom, False, row.original_start, row.original_end]
                else:
                    frame.iloc[i] = row.values.tolist()
            else:
                previous_frame = frame.iloc[i-1]
                if frame.index.max == i:
                    new_end = (row.end - row.start) + previous_frame.end
                    frame.iloc[i] = [row.chr,previous_frame.end, new_end, row['name'], row.gieStain, row.band_base, row.Updated_stain, row.Resolved_band, row.Resolved_stain, row.Path, row.strand, row.chrom, False, row.original_start, row.original_end]
                else:
                    if row.start == previous_frame.end:
                        frame.iloc[i] = row.values.tolist()
                    else:
                        new_end = (row.end - row.start) + previous_frame.end
                        frame.iloc[i] = [row.chr,previous_frame.end,new_end,row['name'],row.gieStain,row.band_base, row.Updated_stain, row.Resolved_band, row.Resolved_stain, row.Path, row.strand, row.chrom, True, row.original_start, row.original_end]
        cyto_list.append(frame)               
    resolved_cyto = pd.concat(cyto_list)
    resolved_stain_cyto = resolve_iscn_bands(resolved_cyto)
    resolved_stain_collapsed_cyto = collapse_bands(resolved_stain_cyto)
    return resolved_stain_collapsed_cyto, resolved_cyto

def resolve_iscn_bands(resolved_cyto):
    """
    Selects gieStain based on prevelance in segments and retains centromere stain when present

    Parameters
    ----------
    resolved_cyto: DataFrame, required
        DataFrame of ISCN coordinates generated within the function: format_iscn_results()
    Returns
    -------
    resolved_stain_cyto: DataFrame
        Orientation resolved, minor cytoband coordinate collapsed_segments Dataframe
    """
    resolved_stain_list = []
    cols = resolved_cyto.columns.tolist()
    grouped_iscn = resolved_cyto.groupby(['Path','chrom','strand'],sort=False)
    for (g,c,s),frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        band_base_group = frame.groupby('band_base')
        for b,band_frame in band_base_group:
            stain_counts = band_frame['gieStain'].value_counts()
            if 'acen' in stain_counts:
                band_frame['Updated_stain'] = 'acen'
            else:
                band_frame['Updated_stain'] = stain_counts.index[0]
            resolved_stain_list.append(band_frame)
    cols.append('Updated_stain')
    resolved_stain_cyto = pd.concat(resolved_stain_list).sort_values(['Path','start','end'])
    return resolved_stain_cyto

def collapse_bands(resolved_stain_cyto):
    """
    Collapses minor cytobands into major cytobands

    Parameters
    ----------
    resolved_stain_cyto: DataFrame, required
        DataFrame of ISCN coordinates generated within the function: resolve_iscn_bands()
    Returns
    -------
    collapsed_bands: DataFrame
        Orientation resolved, minor cytoband coordinate collapsed_segments Dataframe
    """
    collapsed_band_list = []
    grouped_iscn = resolved_stain_cyto.groupby('Path',sort=False)
    for g,frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        indx_final = frame.index.max()
        for indx,row in frame.iterrows():
            if indx == 0:
                segment_start = row
            if (segment_start.chrom != row.chrom) or (segment_start.strand != row.strand) or (segment_start.Resolved_band!= row.Resolved_band):
                append_row = frame.iloc[indx-1]
                append_row.start = segment_start.start
                collapsed_band_list.append(append_row.to_frame().T)
                segment_start = row
            if (indx == indx_final) & (segment_start == row).all():
                collapsed_band_list.append(row.to_frame().T)
            if (indx == indx_final) & (segment_start != row).any():
                append_row = row
                append_row.start = segment_start.start
                collapsed_band_list.append(append_row.to_frame().T)
    collapsed_bands = pd.concat(collapsed_band_list).sort_values(['Path','start','end'])
    return collapsed_bands

def return_chrom(chrom):
    """
    Iterates through string ISCN chromosome and returns chromsome with ISCN nomenclature removed

    Parameters
    ----------
    chrom: str, required
        string ISCN chromosome
    Returns
    -------
    chrom_num: str
        chromsome with ISCN nomenclature removed
    """
    i=1
    for i in range(len(chrom)):
        if chrom[:i].isdigit():
            chrom_num = str(chrom[:i])
        else:
            continue
        i+=1
    return chrom_num

def find_intervals(sub_cyto_frame):
    """
    Finds gaps between segments and reports intervals

    Parameters
    ----------
    sub_cyto_frame: DataFrame, required
        Grouped by Path subsetted cytoband DataFrame
    Returns
    -------
    intervals: DataFrame
        DataFrame with gap filled intervals
    """
    # Perform this on chrom specific segments
    endpoints = sub_cyto_frame.loc[:,['start','end']].stack().sort_values().reset_index(drop=True)
    intervals = pd.DataFrame({'start':endpoints.shift().fillna(0), 
                            'end':endpoints}).astype(int)
    # construct the list of intervals from the endpoints
    intervals['intv'] = [pd.Interval(a,b) for a,b in zip(intervals.start, intervals.end)]
    # these are the original intervals
    orig_invt = pd.arrays.IntervalArray([pd.Interval(a,b) for a,b in zip(sub_cyto_frame.start, sub_cyto_frame.end)])
    # walk through the intervals and compute the intersections
    intervals['total'] = intervals.intv.apply(lambda x: orig_invt.overlaps(x).sum())
    intervals = intervals[~(intervals['start']==intervals['end'])]
    return intervals

def check_paths(sub_cyto_frame, path):
    """
    Function checks paths and identifies potential derivative chromosomes

    Parameters
    ----------
    sub_cyto_frame: DataFrame, required
        Grouped by Path subsetted cytoband DataFrame
    path: str, required
        Path identified by Virtual Karyotype algorithm
    Returns
    -------
    path_intervals: DataFrame
        DataFrame with gap filled intervals
    """
    sub_cyto_sorted = sub_cyto_frame.sort_values(['chr','start','end'])
    if len(sub_cyto_sorted['chr'].unique()) == 1:
        path_intervals = find_intervals(sub_cyto_sorted)
        path_intervals['chr'] = sub_cyto_sorted['chr'].unique()[0]
        contig_id = "{chrom}".format(chrom=sub_cyto_sorted['chr'].unique()[0])
    else:
        intervals_list = []
        sub_cyto_contigs = sub_cyto_sorted.groupby('chr')
        contig_id = "({})".format(';'.join(sub_cyto_sorted['chr'].value_counts().index))
        for chrom,sub_cyto in sub_cyto_contigs:
            sub_path_intervals = find_intervals(sub_cyto)
            sub_path_intervals['chr'] = chrom
            intervals_list.append(sub_path_intervals)
        path_intervals = pd.concat(intervals_list)
    path_intervals['path'] = path
    path_intervals['contig_id'] = contig_id
    return path_intervals

def map_cyto_coords(chrom, start, end, strand, cytoband_filtered, path):
    """
    Maps cytoband coordinates to genomic segments identified by VK algorithm
    
    Parameters
    ----------
    chrom: str, required
        chromosome to subset cytoband_filtered by
    start: str, required
        starting coordinates to subset cytoband_filtered by
    end: str, required
        ending coordinates to subset cytoband_filtered by
    strand: str, required
        if the segment is negative, reverse the ordering of the cytoband segment
    cytoband_filtered: Dataframe, required
        cytoband_filtered Dataframe load by function: read_in_cyto()
    path: str, required
        path identified by VK algorithm
    Returns
    -------
    sub_cyto: DataFrame
        subsetted cytoband Dataframe
    """
    start = int(start)
    end = int(end)
    sub_cyto = cytoband_filtered[(cytoband_filtered['chr'] == chrom) & ((cytoband_filtered['start'] >= start) | (cytoband_filtered['end'] >= start)) & ((cytoband_filtered['end'] <= end)|(cytoband_filtered['start'] <= end))]
    sub_cyto['name'] = path
    sub_cyto.iloc[0,1] = start
    sub_cyto.iloc[-1,2] = end
    sub_cyto['strand'] = strand
    if strand == '-':
        sub_cyto = sub_cyto.iloc[::-1]
    return sub_cyto

def read_in_cyto(cytobands = 'resources/cytoBand.txt'):
    """
    Loads cytoband file as Dataframe
    
    Parameters
    ----------
    cytobands: str, required
        relative path to cytoBand.txt
    Returns
    -------
    cytoband_filtered: Dataframe
        filtered cytoband Dataframe
    """
    chroms = ['chr1', 'chr2', 'chr3', 'chr4', 'chr5', 'chr6', 'chr7', 'chr8', 'chr9', 'chrX', 'chrY', 'chr10', 'chr11', 'chr12', 'chr13', 'chr14', 'chr15', 'chr16', 'chr17', 'chr18', 'chr19', 'chr20', 'chr21', 'chr22']
    cytoband = pd.read_table(cytobands,header=None)
    cytoband.columns = ['chr','start','end','band','stain']
    cytoband_filtered = cytoband[cytoband['chr'].isin(chroms)]
    cytoband_filtered['chr'] = cytoband_filtered['chr'].str.replace("chr", '').replace('X','23').replace('Y','24')
    cytoband_filtered['band_base'] = cytoband_filtered['band'].str.split('.',expand=True)[0]
    cytoband_filtered['start'] = cytoband_filtered['start'].astype(int)
    cytoband_filtered['end'] = cytoband_filtered['end'].astype(int)
    return cytoband_filtered

def read_in_custom_cyto(cytobands = 'resources/hg38_400_level_cytoband.tsv'):
    """
    Loads cytoband file as Dataframe
    
    Parameters
    ----------
    cytobands: str, required
        relative path to cytoBand.txt
    Returns
    -------
    cytoband_filtered: Dataframe
        filtered cytoband Dataframe
    """
    cytoband = pd.read_table(cytobands)
    cytoband['chr'] = cytoband['chr'].astype(str)
    cytoband['start'] = cytoband['start'].astype(int)
    cytoband['end'] = cytoband['end'].astype(int)
    return cytoband

def check_majority_rows(df, column_name, condition_value, end_row):
    subset = df.loc[:end_row]  # Subset the dataframe until the end row
    count_p = subset[column_name].eq(condition_value).sum()  # Count the number of 'p' values
    count_q = subset[column_name].eq('q').sum()  # Count the number of 'q' values
    return count_q > count_p  

def check_strand(frame):
    frame = frame.reset_index(drop=True)
    status = False
    frame['arm'] = frame['band_base'].str.slice(0,1)
    if (len(frame['strand'].unique()) == 1) and (frame['strand'].unique()[0] == '-'):
        status = True
    if (len(frame['strand'].unique()) == 1) and (frame['strand'].unique()[0] == '+'):
        status = False
    else:
        if 'acen' in frame['Resolved_stain']:
            end_row = frame.loc[frame['Resolved_stain']=='acen'].index.tolist()[0]
            status = check_majority_rows(frame, 'arm', 'p', end_row)
        else:
            end_row = int(frame.shape[0]/2)
            status = check_majority_rows(frame, 'arm', 'p', end_row)
    return status

def orient_p_to_q(resolved_cyto):
    """
    Resolves non-contiguous genomic segments and embeds major cytobands in paths detected by VK algorithm

    Parameters
    ----------
    resolved_cyto: DataFrame, required
        DataFrame of ISCN coordinates generated within the function: resolve_iscn_cyto()
    Returns
    -------
    resolved_strand_iscn_sorted: DataFrame
        sorted by presence of cetromere and ordered by autosome, iscn relabled cytoband Dataframe from relabel_paths()
    """
    iscn_cyto_copy = resolved_cyto.copy()
    cyto_list = []
    grouped_iscn = iscn_cyto_copy.groupby('Path')
    for g,frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        if check_strand(frame):
            frame = frame.iloc[::-1].reset_index(drop=True)
            for i,row in frame.iterrows():
                if i == 0:
                    if row.start != 0:
                        new_end = (row.end - row.start) 
                        frame.iloc[i] = [row.chr,0,new_end,row['name'],row.gieStain,row.band_base, row.Updated_stain, row.Resolved_band, row.Resolved_stain, row.Path, row.strand, row.chrom, row.bp, row.original_start, row.original_end]
                    else:
                        frame.iloc[i] = row.values.tolist()
                else:
                    previous_frame = frame.iloc[i-1]
                    if frame.index.max == i:
                        new_end = (row.end - row.start) + previous_frame.end
                        frame.iloc[i] = [row.chr,previous_frame.end,new_end,row['name'],row.gieStain,row.band_base, row.Updated_stain, row.Resolved_band, row.Resolved_stain, row.Path, row.strand, row.chrom, row.bp, row.original_start, row.original_end]
                    else:
                        if row.start == previous_frame.end:
                            frame.iloc[i] = row.values.tolist()
                        else:
                            new_end = (row.end - row.start) + previous_frame.end
                            frame.iloc[i] = [row.chr,previous_frame.end,new_end,row['name'],row.gieStain,row.band_base, row.Updated_stain, row.Resolved_band, row.Resolved_stain, row.Path, row.strand, row.chrom, row.bp, row.original_start, row.original_end]
            cyto_list.append(frame)
        else:
            cyto_list.append(frame)              
    resolved_strand_cyto = pd.concat(cyto_list)
    resolved_strand_iscn_sorted = relabel_paths(resolved_strand_cyto)
    return resolved_strand_iscn_sorted

def relabel_paths(resolved_strand_cyto):
    """
    Resolves non-contiguous genomic segments and embeds major cytobands in paths detected by VK algorithm
    Parameters
    ----------
    resolved_cyto: DataFrame, required
        DataFrame of ISCN coordinates generated within the function: format_iscn_results()
    Returns
    -------
    resolved_strand_iscn_sorted: DataFrame
        sorted by presence of cetromere and ordered by autosome, iscn relabled cytoband Dataframe
    """
    iscn_cyto_copy = resolved_strand_cyto.copy()
    iscn_cyto_copy['chrom'] = iscn_cyto_copy['chrom'].replace({'23':'X','24':'Y'})
    cyto_list = []
    grouped_iscn = iscn_cyto_copy.groupby('Path')
    for g,frame in grouped_iscn:
        frame = frame.reset_index(drop=True)
        if frame['Updated_stain'].isin(['acen']).any():
            centromere = frame[frame['Updated_stain'] == 'acen']['chrom'].unique()
            if len(centromere) == 1:
                frame['centromere'] = 0
                frame['sort_chrom'] = centromere[0]
            else:
                frame['centromere'] = 1
                frame['sort_chrom'] = frame[frame['chrom'].isin(centromere)]['chrom'].value_counts().index[0]
            contigs = frame['chrom'].unique()
            if len(contigs) == 1:
                frame['iscn'] = "{path} : {contig}".format(path=g,contig=contigs[0])
            else:
                if len(centromere) == 1:
                    non_centromere = list(set(contigs) - set(centromere))
                    frame['iscn'] = "{path} : der({centromere})t({contig})".format(path=g,centromere=centromere[0],contig=';'.join(map(str,non_centromere)))
                else:
                    #Dicentric Chromosomes
                    non_centromere = list(set(contigs) - set(centromere))
                    if len(non_centromere) != 0:
                        frame['iscn'] = "{path} : dic({centromere})t({contig})".format(path=g,centromere=';'.join(map(str,centromere)),contig=';'.join(map(str,non_centromere)))
                    else:
                        frame['iscn'] = "{path} : dic({centromere})".format(path=g,centromere=';'.join(map(str,centromere)))
            cyto_list.append(frame)
        else:
            frame['centromere'] = 2
            contigs = frame['chrom'].unique()
            if len(contigs) == 1:
                frame['iscn'] = "{path} : {contig}".format(path=g,contig=contigs[0])
                frame['sort_chrom'] = contigs[0]
            else:
                frame['iscn'] = "{path} : {contig}".format(path=g,contig=';'.join(map(str,contigs)))
                frame['sort_chrom'] = frame[frame['chrom'].isin(contigs)]['chrom'].value_counts().index[0]
            cyto_list.append(frame)
    resolved_strand_iscn_cyto = pd.concat(cyto_list)
    index_cols = ['iscn', 'start', 'end', 'name', 'gieStain', 'band_base', 'Path', 'strand', 'chrom', 'bp', 'original_start', 'original_end', 'Updated_stain', 'centromere', 'chr','sort_chrom','Resolved_band','Resolved_stain']
    resolved_strand_iscn_cyto['sort_chrom'] = resolved_strand_iscn_cyto['sort_chrom'].replace({'X':'23','Y':'24'}).astype(int)
    resolved_strand_iscn_sorted = resolved_strand_iscn_cyto.sort_values(['centromere','sort_chrom','chr','start','end']).reindex(index_cols,axis=1).rename(columns={'iscn':'chr','chr':'iscn'})
    return resolved_strand_iscn_sorted

def calculate_overlap_percentage_by_row(df, threshold=0.6, size_threshold=0.1):
    """
    Calculates the overlap percentage of two sets of values for every row relative to the first row.
    If all rows overlap by more than a given threshold and the average delta of 'size' ratios
    is below size_threshold, return only the first row. Otherwise, return the first row and any rows 
    that don't meet these criteria. If 'size' is NaN, assume the sizes are equal.
    Arguments:
    df -- pandas DataFrame containing columns "ref_start", "ref_end", and "size"
    threshold -- percentage threshold for filtering rows based on overlap (default 0.95)
    size_threshold -- threshold for filtering rows based on 'size' ratios (default 0.1)
    Returns:
    df_filtered -- Filtered DataFrame.
    """
    if df.empty:
        return df
    overlap_percentages = []
    size_ratios = []
    start1, end1, size1 = df.iloc[0][["ref_start", "ref_end", "size"]]
    min1, max1 = min(start1, end1), max(start1, end1)
    for i in range(len(df)):
        start2, end2, size2 = df.iloc[i][["ref_start", "ref_end", "size"]]
        min2, max2 = min(start2, end2), max(start2, end2)
        overlap = max(0, min(max1, max2) - max(min1, min2))
        length = (max1 - min1) + (max2 - min2)
        overlap_percentage = 2 * overlap / length if length != 0 else 0
        # If 'size' is NaN, assume the sizes are equal
        if pd.isna(size1) or pd.isna(size2):
            size_ratio = 0
        else:
            size_ratio = abs(size1/size2 - 1) + abs(size2/size1 - 1)
        overlap_percentages.append(overlap_percentage)
        size_ratios.append(size_ratio)
    df['Overlap Percentage'] = overlap_percentages
    df['Size Ratio'] = size_ratios
    # If all rows (except the first) overlap by more than the threshold and the average size ratio is less than size_threshold
    # then return only the first row
    if all(percentage > threshold for percentage in overlap_percentages[1:]) and np.mean(size_ratios[1:]) < size_threshold:
        return df.iloc[[0]]
    # Otherwise, return the first row and any rows that don't meet these criteria
    else:
        sub_frame = df[(df['Overlap Percentage'] >= threshold) & (df['Size Ratio'] <= size_threshold)]
        rec_frame = df[~df.index.isin(sub_frame.index)]
        rec_results = calculate_overlap_percentage_by_row(rec_frame)
        joined_results = pd.concat([sub_frame.iloc[[0]],rec_results])
    return joined_results

def filter_empty_paths(df):
    """
    Filters out rows from the DataFrame where the 'Paths' column contains an empty list.
    Args:
    df (pd.DataFrame): Input DataFrame with a 'Paths' column.
    Returns:
    pd.DataFrame: DataFrame without rows that have empty 'Paths'.
    """
    return df.loc[df['Paths'].astype(str) != '[]']

def parse_smap_segments(smap_segments):
    """ Parses smap segments file associated SVs with particular genomic segments in VK output table

    Args:
        smap_segments (str): relative path to smap segments csv file
    """
    segments = pd.read_csv(smap_segments)
    filtered_segments = filter_empty_paths(segments)
    segment_group = filtered_segments.groupby(['Segments','ref_c_id1','sv_type'])
    consolidated_segments = []
    for (seg,ch1, svtype),frame in segment_group:
        if frame.shape[0] == 1:
            consolidated_segments.append(frame)
        else:
            frame = frame.sort_values(['confidence','size'],ascending=[False,False])
            subset_frame = calculate_overlap_percentage_by_row(frame).iloc[:,:-2]
            consolidated_segments.append(subset_frame)
    segment_frame = pd.concat(consolidated_segments).sort_values(['ref_c_id1'])
    segment_frame_filtered = segment_frame.drop_duplicates(subset=['ref_c_id1','ref_c_id2','ref_start','ref_end','confidence','sv_type','size','VAF','Paths'])
    segment_frame_filtered['Paths'] = segment_frame_filtered['Paths'].apply(ast.literal_eval)
    return segment_frame_filtered

def main():
    parser = argparse.ArgumentParser(
        """Function accepts generates formats Virtual Karyotype results to be visualized using KaryoploteR"""
    )
    parser.add_argument('--iscn_format', type=str, help="relative path to VK ISCN results file")
    parser.add_argument('--vk_results', type=str, help="relative path to VK results file")
    parser.add_argument('--smap_segments', type=str, help="relative path to VK smap segments results file")
    parser.add_argument('--cytoband', type=str, help="relative path to cytoband file")
    parser.add_argument('--cytobands_out', type=str, help="relative path to granges formatted output file")
    parser.add_argument('--genome_out', type=str, help="relative path to granges formatted output file")
    parser.add_argument('--contig_orientation_out', type=str, help="relative path to granges formatted output file")
    parser.add_argument('--kprect_out', type=str, help="relative path to granges formatted output file")
    parser.add_argument('--svlabel_frame_out', type=str, help="relative path to granges formatted output file")


    # parse command line arguments
    args = parser.parse_args()
    print(args)
    iscn_format = args.iscn_format
    cytoband = args.cytoband
    cytobands_out = args.cytobands_out
    genome_out = args.genome_out
    contig_orientation_out = args.contig_orientation_out
    kprect_out = args.kprect_out
    smap_segments = args.smap_segments
    vk_results = args.vk_results
    svlabel_frame_out = args.svlabel_frame_out

    format_iscn_results(iscn_format=iscn_format, cytobands=cytoband, cytobands_out=cytobands_out, genome_out=genome_out, contig_orientation_out=contig_orientation_out, kprect_out=kprect_out, smap_segments=smap_segments, vk_results=vk_results, svlabel_frame_out=svlabel_frame_out)

if __name__ == "__main__":
    main()